#' score test with missing data for time-to-event data
#'
#' This function computes the p-values for proportional hazards and proportional odds models using a supermum score test.
#'
#' @param x matrix of covariates
#' @param y survival outcome
#' @param s a covariate of interets, allowed to be missing
#' @param w potentially high-dimensional vector of covariates
#' @param r indicator of whether s is observed
#' @param delta censoring indicator (1 = event, 0 = censored)
#' @param Z matrix of permutation data for hypothesis testing,
#'        can be generated by Z = mvrnorm(500000, mu = c(0,0), Sigma = matrix(c(1,0,0,1), nrow = 2))
#' @return A list containing p-values for supremum test, proportional hazards, and proportional odds models.
#' @useDynLib AssoTest
#' @importFrom  stats cov
#' @export

scoretest_supre <- function(x, y, s, w, r, delta, Z){
  ## Helper functions ##
  G <- function(x, RHO){
    if (RHO == 1) {
      x
    } else {
      log(1 + x)
    }
  }

  dG <- function(x, RHO){
    if (RHO == 1) {
      rep(1, length(x))
    } else {
      1 / (1 + x)
    }
  }

  ddG <- function(x, RHO){
    if (RHO == 1) {
      rep(0, length(x))
    } else {
      - 1 / (1 + x)^2
    }
  }

  dddG <- function(x, RHO){
    if (RHO == 1) {
      rep(0, length(x))
    } else {
      2 / (1 + x)^3
    }
  }

  dlogdG <- function(x, RHO){
    ddG(x, RHO) / dG(x, RHO)
  }

  ddlogdG <- function(x, RHO){
    (dddG(x, RHO) * dG(x, RHO) - ddG(x, RHO)^2) / (dG(x, RHO)^2)
  }

  function_proposed <- function(x, y, s, w, r, delta, nu){
    dimy <- dim(y)
    nrowy <- ifelse(is.null(dimy), length(y), dimy[1])
    n <- nrowy
    censor <- which(delta == 0)
    EM_output <- Trans_EM_rcpp(Y = y, CI = delta, X = x, RHO = nu)
    alphahat <- EM_output$beta           #### estimated alpha
    hazardhat <- EM_output$hazard   #### estimated jump size

    wtilde <- cbind(1, w)
    sfit <- lm(s[r==1] ~ 0 + wtilde[r==1, ])
    gammahat <- sfit$coefficient
    # s[r==0] <- 0 ## change NA values to 0
    s_new <- r * s + (1 - r) * (wtilde %*% gammahat)

    expxa <- exp(x %*% alphahat)
    # hazard_cum <- lapply(1:n, function(i) sum(hazardhat[1:i]))
    hazard_cum <- cumsum(hazardhat)
    xi <- hazard_cum * expxa
    dG_xi <- dG(xi, nu)
    ddG_xi <- ddG(xi, nu)
    dlogdG_xi <- dlogdG(xi, nu)
    ddlogdG_xi <- ddlogdG(xi, nu)

    G_xi <- G(xi,nu)

    lik_all <- x%*%alphahat+log(hazardhat)+log(dG_xi)-G_xi
    lik <- sum(lik_all[-censor])


    ### Differentiation wrt lambda ###
    U_lambda <- matrix(0, n, n)
    term_1 <- delta / hazardhat
    temp <- dlogdG_xi * expxa * delta - dG_xi * expxa
    diag(U_lambda) <- term_1 + temp
    for (j in 1:(n-2)) {
      U_lambda[(j+1):n, j] <- temp[(j+1):n]
    }
    U_lambda <- U_lambda[, -censor]

    I_lambdalambda <- matrix(0, n, n)
    ### diagnol elements ###
    term_1 <- - delta / (hazardhat^2)
    temp <- ddlogdG_xi * expxa^2 * delta - ddG_xi * expxa^2
    term_2 <- vector()
    term_2[1] <- sum(temp)
    for (i in 2:n) term_2[i] <- term_2[i-1] - temp[i-1]
    diagnol <- term_1 + term_2
    ### submatrix ###
    for (i in 2:n) I_lambdalambda[i, 1:(i-1)] <- rep(term_2[i], i-1)
    I_lambdalambda <- I_lambdalambda + t(I_lambdalambda)

    diag(I_lambdalambda) <- diagnol
    I_lambdalambda <- - I_lambdalambda[-c(censor), -c(censor)]

    I_lambdaalpha <- matrix(0, n, ncol(x))
    temp <- ddlogdG_xi * xi * expxa * delta + dlogdG_xi * expxa * delta -
      ddG_xi * expxa * xi - dG_xi * expxa
    temp <- c(temp) * x
    I_lambdaalpha[1,] <- apply(temp, 2, sum)
    for (i in 2:n) I_lambdaalpha[i,] <- I_lambdaalpha[i-1,] - temp[i-1,]
    I_lambdaalpha <- - I_lambdaalpha[-c(censor), ]

    temp <- (ddlogdG_xi * xi * delta + dlogdG_xi * delta - ddG_xi * xi - dG_xi) * expxa * s_new
    I_betalambda <- vector()
    I_betalambda[1] <- sum(temp)
    for(i in 2:n) I_betalambda[i] <- I_betalambda[i-1] - temp[i-1]
    I_betalambda <- - I_betalambda[-c(censor)]


    omega <- delta + dlogdG_xi * xi * delta - dG_xi * xi
    ### Differentiation wrt alpha ###
    U_alpha <- c(omega) * x
    temp <- c(xi^2 * (ddlogdG_xi * delta - ddG_xi) + xi *  (dlogdG_xi * delta - dG_xi)) * x
    I_alphaalpha <- - t(temp) %*% x
    I_betaalpha <- - t(temp) %*% s_new




    ### zeta = (alpha, lambda) ###
    U_zeta <- cbind(U_alpha, U_lambda)
    I_betazeta <- c(I_betaalpha, I_betalambda)
    part1 <- cbind(I_alphaalpha, t(I_lambdaalpha))
    part2 <- cbind(I_lambdaalpha, I_lambdalambda)
    I_zetazeta <- rbind(part1, part2)




    ### Differentiation wrt gamma ###
    #U_gamma <- r * (s - wtilde%*%gammahat) * wtilde
    I_gammagamma <- t(r * wtilde) %*% wtilde

    I_betagamma <- - t(omega) %*% ((1 - r) * wtilde)


    ss_expand <- omega * s_new
    scorestatistic <- sum(ss_expand) / sqrt(n)
    expand_ss_1 <- omega * s_new
    expand_ss_2 <- - r * (s - wtilde%*%gammahat) * wtilde %*% solve(I_gammagamma, t(I_betagamma))
    expand_ss_3 <- - U_zeta %*% solve(I_zetazeta, I_betazeta)
    expand_ss_all <- expand_ss_1 + expand_ss_2 + expand_ss_3
    estimated_variance <- var(expand_ss_all)
    pv <- pnorm(abs(scorestatistic), mean = 0, sd = sqrt(estimated_variance), lower.tail = FALSE) * 2
    # object <- list(scorestatistic = scorestatistic, pv = pv, estimated_variance = estimated_variance)
    # object

    output <- list(scorestatistic = scorestatistic, pv = pv, estimated_variance = estimated_variance, expand_ss = expand_ss_all, lik = lik)
    output

  }

  output_proposed_cox <- function_proposed(x = x, y = y, s = s, w = w, r = r, delta = delta, nu = 1)
  output_proposed_odd <- function_proposed(x = x, y = y, s = s, w = w, r = r, delta = delta, nu = 0)

  score_proposed_cox <- output_proposed_cox[[1]]
  score_proposed_odd <- output_proposed_odd[[1]]
  sd_proposed_cox <- sqrt(output_proposed_cox[[2]])
  sd_proposed_odd <- sqrt(output_proposed_odd[[2]])
  pv_proposed_cox <- output_proposed_cox[[3]]
  pv_proposed_odd <- output_proposed_odd[[3]]

  teststatistic_proposed_cox <- abs(score_proposed_cox) / sd_proposed_cox
  teststatistic_proposed_odd <- abs(score_proposed_odd) / sd_proposed_odd
  Cox_Mat <-  cov(cbind(output_proposed_cox[[4]], output_proposed_odd[[4]]))
  Balance <- diag(1/sqrt(diag(Cox_Mat)))
  Cox_Mat <- Balance %*% Cox_Mat %*% Balance
  z <- Z %*% chol(Cox_Mat)
  z_max <- apply(abs(z), 1, max)
  pv_proposed_max <- sum(z_max > max(teststatistic_proposed_cox, teststatistic_proposed_odd)) / length(z_max)

  object <- list(pv_max = pv_proposed_max, pv_cox = pv_proposed_cox, pv_odd = pv_proposed_odd)
  object
}


